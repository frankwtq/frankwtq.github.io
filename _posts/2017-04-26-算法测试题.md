---
layout: post
title: 算法测试题
category : 讨论小结
tags: [算法]
stickie: true
---


# 算法小测试
> 实验室大师兄开了个小灶，讲了一些简单的算法题给我们开拓一下思路。现在把这次讲到的几个测试题记录在这里，一来是再过一遍加深印象，二来以后也可以看看。

## 测试题1--判断和为s的元素的存在性

题目：已知数组```a[0],a[1],...,a[i],a[i+1],...,a[n]```以及一个整数```s```;其中```n```范围为```10^5```,```a[i]```的范围为```10^9```,判断数组```a[n]```中是否存在```a[i]```和```a[j]```,使得```s=a[i]+a[j]```,其中```i```可以等于```j```。

我的思路：最快能想到的自然是枚举法，就是将数组a[n]中的每两个元素都相加看能不能等于s，但是这个方法很蠢，时间复杂度是o(n^2)。
那有没有更好的方法？当然有，其实这种从数组中找数的题如果一遍遍历无法解决问题，那么就要先进行一下排序处理了，虽然排序过程会增加复杂度，但是排序后就可以利用元素之间的相关信息解题，事半功倍。
所以先对数字进行排序，方法很多，快排来做就是o(nlog(n))。
堆排序后的数组从两头开始遍历，i=0开始，j=n开始，此时a[i]最小，a[j]最大。然后按照下面的规则进行移动：
  
<pre>
while(i<=j){
if a[i]+a[j]==s 
  return true;
else if a[i]+a[j]<s
  i++;
else if a[i]+a[j]>s
  j--;
}
return false;
</pre>
  
这种方法对于排序后的数组来说得到结果的时间复杂度是o(n);再考虑前面排序的过程，整体的复杂度就是max(o(nlog(n)),o(n))=o(nlog(n))。

要理解这种方法其实可以把a[i]+a[j]想象为一个二维矩阵，纵轴和横轴都是a[0]...a[n]，形状如：
<pre>
--------------------------------->
|        a[0],  a[1],  a[2],...,  a[n]
| a[0]   -      -        -         -
| a[1]   -      -        -         -
| ...
| a[n]   -      -        -         -
\/
</pre>
  
矩阵中元素的特点是随着箭头的方向，矩阵中元素所对应横纵坐标a[i]和a[j]之和不断增大。再明显点就是：
<pre>
--------------------------------->
|        a[0],  a[1],  a[2],...,  a[n]
| a[0]   小      小     小        未2
| a[1]   小      小      X        大
| ...
| a[n]   未1     未1     大        大
\/
</pre>
  
矩阵中每个元素的值都是其横纵坐标a[i]与a[j]的和，当前位置为X，“小”对应位置的值小于“X”对应的值，“大”对应位置的值大于“X”对应的值，剩余的“未1”和“未2”对应的值和“X”的关系是未知的。这道题就转化为判断在这个矩阵中是否存在值为s的元素。
现在假设当前值x比s小，说明“小”对应的值都要小于s，那么我们应该在“大”，“未1”和“未2”中继续找；反之亦然，当前置x比s大时，说明“大”对应的值都要大于s，那么我们就应该在“小”，“未1”和“未2”中继续找。这个过程就是对搜索区域进行简化排除的过程。
那么现在又有一个问题，这每一次的简化得到的剩余的区域是个多边形，并不是矩形，不能很好的实现在一个矩形模板上简化问题的目的。如何才能做到每一次简化后剩余的还是一个矩形呢。很简单，直到随意选择左下角或者右上角作为起始判断位置，然后进行简化就可以了。比如从右上角开始，那么第一次简化时x>s就可以排除最右边那一列，如果x<s就可以排除最上边那一行，剩下的就还是一个矩形了。然后不断简化，直到排除掉所有的元素，或者找到x==s时为止，问题就解决了。
把这个理论实现为代码时就是像上面的伪代码一样，从最左和最右同时开始遍历。
当然还有很多其他的方法可以解这道题，但是这种方法应该是时间复杂度最小的了，如果有人有更好的方法可以下来交流。
  
## 测试题2--计算三角形面积
  
题目：给定一个三角形三个定点的坐标，计算这个三角形的面积。
解法：这个题有很多解法，较简单的就是通过公式计算，比如：
1. 海伦公式：sqrt(d(d-a)(d-b)(d-c))，其中a,b,c为三角形的三边长，d为三边和的一般，就是d=(a+b+c)/2;这种解法需要使用公式先计算出三条边的长度。算法缺点就是计算机计算时会有误差存在。
2. 使用```面积=底×高/2```的公式，同样的也需要使用其他公式计算高，还有边长，缺点也是会有误差。
3. 利用[向量外积公式](http://baike.baidu.com/link?url=wlqGs-UZYr-vdzMO6PPZhbnf1hTmCMXiCNDnSwPeEczpXjp5Uajl0oZi8iyuZ5HHK6UPabrHIZ2QQNJAEU6UbfPqmjzmhmMph1CVuUC8mAW)：向量的外积还是一个向量，新向量的模为：``` | ```**AB**×**AC**``` | ```=(``` | ```**AB**``` | ```×``` | ```**AC**``` | ```×sin(θ));三角形面积=(1/2)(**AB**×**AC**)=(1/2)(|**AB**|×|**AC**|×sin(θ))；所以可以根据向量的外积得到三角形的面积。外积的坐标表示为：```(x1,y1,z1)×(x2,y2,z2)=(y1z2-y2z1,z1x2-z2x1,x1y2-x2y1)```，向量的外积是建立在三维空间上的，我们要求三角形的面积就可以把其中一个维度的坐标定位0，比如z1=z2=0，这样就得到``` (x1,y1,0)×(x2,y2,0)=(0,0,x1y2-x2y1) ```。假设三点A(x1,y1),B(x2,y2),C(x3,y3)，则**AB**=(x2-x1,y2-y1),**AC**=(x3-x1,y3-y1);则面积=(1/2)``` | ```**AB**×**AC**``` | ```=(1/2)((x2-x1)×(y3-y1)-(y2-y1)×(x3-x1));
4. [多边形面积公式](http://blog.csdn.net/hemmingway/article/details/7814494)：就是将多边形分割为多个三角形，然后求所有三角形的总和，所以本质也是利用了上边的向量外积公式。
  
## 测试题3--求最短距离
题目：在二维直角坐标系中有一个与坐标平行的矩阵，给出这个矩阵的四个点A,B,C,D的坐标，以及一个矩阵外的P点坐标，计算P点到矩阵边界上任意一点的距离中的最短距离。
  
我的思路：这个题最开始我想到的是把矩形的四条边无限延长，这样坐标系就被分为了8个区域，当P点在这8个区域中的正上下左右方时，最短距离就是P点横坐标和纵坐标与A,B,C,D四个点坐标的横坐标和纵坐标差值中的最小值；而当P点在剩余的四个区域时，最短距离就是P点和A,B,C,D四个点距离中的最小值。
我的这个思路当然是可行的，但是不够简洁，虽然和最优答案很接近了，但是没有抓住本质。下面来说以下更好的解法。

假定最短连线中除P(p1,p2)点外的另一个点为S(s1,s2)，那么``` s1=max(min(a1,b1),min(max(a1,b1),p1)) ```;``` s2=max(min(a2,c2),min(max(a2,c2),p2)) ```,然后直接求SP的距离就可以了。这里的s1就是a1，b1和p1三个数排序后位于中间的那个数的值，s2就是a2，c2和p2三个数排序后位于中间的那个数的值。  

---------
。。。未完待续。。。
